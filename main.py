import openai
import os
from dotenv import find_dotenv, load_dotenv
import time
import logging
from datetime import datetime
import requests
import json

# TODO: We have to delete all the imports we dont need.

# TODO: We need to somehow have better architecture for the assistants instructions name and all that, maybe another file with
# TODO: some constants would be a good idea.

load_dotenv()
# openai.api_key = os.environ.get("OPENAI_API_KEY")
# defaults to getting the key using os.environ.get("OPENAI_API_KEY")
# if you saved the key under a different environment variable name, you can do something like:
# client = OpenAI(
#   api_key=os.environ.get("CUSTOM_ENV_NAME"),
# )

client = openai.OpenAI()
model = "gpt-3.5-turbo-16k"


class AssistantManager:
    thread_id = ""
    assistant_id = ""

    def __init__(self, model: str = model):
        """
        Initializes an instance of the AssistantManager class.

        This constructor initializes the AssistantManager with a specified model and sets up the initial state for the assistant and thread management. 
        It attempts to retrieve existing assistant and thread objects using their IDs if they are already set. If the IDs are not set, the assistant and 
        thread attributes are initialized as None.

        Parameters:
        - model (str): The model identifier to be used with the OpenAI API. Defaults to the global `model` variable.

        Attributes:
        - client (OpenAI): An instance of the OpenAI client initialized with the API key.
        - model (str): The model identifier to be used for the assistant.
        - assistant (OpenAI Assistant or None): The assistant object retrieved from OpenAI, or None if not yet created or retrieved.
        - thread (OpenAI Thread or None): The thread object retrieved from OpenAI, or None if not yet created or retrieved.
        - run (None): Placeholder for future run objects created during the assistant's operation.
        - summary (None): Placeholder for storing summaries generated by the assistant.
        """
        self.client = client
        self.model = model
        self.assistant = None
        self.thread = None
        self.run = None

        # Retrieve existing assistant and thread if IDs are already set
        if AssistantManager.assistant_id:
            self.assistant = self.client.beta.assistants.retrieve(
                assistant_id=AssistantManager.assistant_id
            )
        if AssistantManager.thread_id:
            self.thread = self.client.beta.threads.retrieve(
                thread_id=AssistantManager.thread_id
            )

    def create_assistant(self, name, instructions, tools):
        """
        Creates a new assistant in the OpenAI platform if one does not already exist for this instance.

        This method checks if an assistant has already been created for this instance of the AssistantManager class. 
        If not, it proceeds to create a new assistant on the OpenAI platform using the provided name, instructions, and tools. 
        The newly created assistant's ID is then stored in the class variable `assistant_id`, and the assistant object is stored in the instance variable `assistant`. 
        A message displaying the new assistant's ID is printed to the console.

        Parameters:
        - name (str): The name of the assistant to be created.
        - instructions (str): Instructions for the assistant, describing its purpose or task.
        - tools (list): A list of tools that the assistant can use to perform its tasks.

        Returns:
        - None
        """
        if not self.assistant:
            assistant_obj = self.client.beta.assistants.create(
                name=name, 
                instructions=instructions, 
                tools=tools, 
                model=self.model
            )
            AssistantManager.assistant_id = assistant_obj.id
            self.assistant = assistant_obj
            print(f"AssisID:::: {self.assistant.id}")

    def create_thread(self):
        """
        Creates a new thread in the OpenAI platform if one does not already exist for this instance.

        This method checks if a thread has already been created for this instance of the AssistantManager class. 
        If not, it proceeds to create a new thread on the OpenAI platform. The newly created thread's ID is then stored in the class variable `thread_id`, 
        and the thread object is stored in the instance variable `thread`. A message displaying the new thread's ID is printed to the console.

        Parameters:
        - None

        Returns:
        - None
        """
        if not self.thread:
            thread_obj = self.client.beta.threads.create()
            AssistantManager.thread_id = thread_obj.id
            self.thread = thread_obj
            print(f"ThreadID::: {self.thread.id}")

    def add_message_to_thread(self, role, content):
        """
        Adds a message to an existing thread in the OpenAI platform.

        This method checks if a thread object exists for the current instance of the AssistantManager class. 
        If a thread exists, it creates a new message in this thread using the OpenAI API. The message is defined by its role (e.g., "user" or "system") and its content.

        Parameters:
        - role (str): The role of the message, indicating who is the sender of the message. 
        Common roles include "user" for messages sent by the user and "system" for messages sent by the system or assistant.
        - content (str): The actual content of the message to be added to the thread.

        Returns:
        - None
        """
        if self.thread:
            self.client.beta.threads.messages.create(
                thread_id=self.thread.id, role=role, content=content
            )

    def run_assistant(self, instructions):
        """
        Initiates the assistant to process a set of instructions within a specific thread.

        This method checks if both the thread and assistant objects exist for the current instance. 
        If they do, it creates a new run within the specified thread using the assistant. The run is tasked with processing the given instructions. 
        The method stores the created run object in the instance variable `self.run` for future reference.

        Parameters:
        - instructions (str): The instructions or query that the assistant needs to process.

        Returns:
        - None
        """
        if self.thread and self.assistant:
            self.run = self.client.beta.threads.runs.create(
                thread_id=self.thread.id,
                assistant_id=self.assistant.id,
                instructions=instructions,
            )

    def process_message(self):
        """
        Processes the last message in the thread and updates the summary attribute.

        This method retrieves the list of messages from the current thread using the OpenAI API. 
        It then extracts the last message from this list, assuming it to be the most recent response from the assistant. 
        The role and content of this message are extracted, and the content is appended to the summary list. 
        The summary attribute of the instance is then updated to a string containing all items in the summary list, joined by newline characters. 
        Additionally, a log message is printed to the console displaying the role and content of the last message.

        Parameters:
        - None

        Returns:
        - None
        """
        if self.thread:
            messages = self.client.beta.threads.messages.list(thread_id=self.thread.id)

            last_message = messages.data[0]
            role = last_message.role
            response = last_message.content[0].text.value
            # TODO: here we have to process the response from the assistant and output it as a voice message
            
            
            
            print(f"RESPONSE-----> {role.capitalize()}: ==> {response}")

            # for msg in messages:
            #     role = msg.role
            #     content = msg.content[0].text.value
            #     print(f"SUMMARY-----> {role.capitalize()}: ==> {content}")

    def call_required_functions(self, required_actions):
        """
        Calls the required functions based on the actions specified by the OpenAI Assistant.

        This method iterates through a list of tool calls specified in the `required_actions` parameter. 
        For each tool call, it identifies the function to be called by its name and passes the necessary arguments to it.
        If the function call is successful, the output is formatted and added to a list of tool outputs. 
        These outputs are then submitted back to the Assistant via the OpenAI API.

        Parameters:
        - required_actions (dict): A dictionary containing the details of the tool calls required by the Assistant. 
        This includes the function name and arguments for each tool call.

        Returns:
        - None: This method does not return a value but submits tool outputs back to the Assistant.

        Raises:
        - ValueError: If an unknown function name is encountered in the tool calls, a ValueError is raised.
        """
        if not self.run:
            return
        tool_outputs = []

        for action in required_actions["tool_calls"]:
            func_name = action["function"]["name"]
            arguments = json.loads(action["function"]["arguments"])

            if func_name == "get_news":
                output = get_news(topic=arguments["topic"])
                print(f"STUFFFFF;;;;{output}")
                final_str = ""
                for item in output:
                    final_str += "".join(item)

                tool_outputs.append({"tool_call_id": action["id"], "output": final_str})
            else:
                raise ValueError(f"Unknown function: {func_name}")

        print("Submitting outputs back to the Assistant...")
        self.client.beta.threads.runs.submit_tool_outputs(
            thread_id=self.thread.id, run_id=self.run.id, tool_outputs=tool_outputs
        )

    def wait_for_completion(self):
        """
        Waits for the completion of the assistant's processing or for a required action to be performed.

        This method continuously checks the status of the current run within the thread. 
        It polls the OpenAI API at regular intervals to retrieve the run's status. If the status is 'completed', it calls the `process_message` method to process the 
        final message from the assistant. If the status is 'requires_action', it calls the `call_required_functions` method to perform any required actions specified by 
        the assistant. The loop breaks once the run status is 'completed', indicating that the assistant has finished processing.

        Parameters:
        - None

        Returns:
        - None
        """
        if self.thread and self.run:
            while True:
                time.sleep(5)  # Wait for 5 seconds before checking the status again
                run_status = self.client.beta.threads.runs.retrieve(
                    thread_id=self.thread.id, run_id=self.run.id
                )
                print(f"RUN STATUS:: {run_status.model_dump_json(indent=4)}")

                if run_status.status == "completed":
                    self.process_message()  # Process the final message from the assistant
                    break  # Exit the loop as the assistant has completed processing
                elif run_status.status == "requires_action":
                    print("FUNCTION CALLING NOW...")
                    self.call_required_functions(
                        required_actions=run_status.required_action.submit_tool_outputs.model_dump()
                    )  # Perform any required actions specified by the assistant

    # Run the steps
    def run_steps(self):
        """
        Retrieves and lists all the steps of a run within a specific thread.

        This method calls the OpenAI API to list all the steps associated with a particular run in a thread.
        It prints the retrieved steps to the console for debugging or informational purposes. 
        The steps provide insights into the sequence of actions or processes undertaken by the assistant during its operation.

        Returns:
        - list: A list of step objects associated with the run. Each step object contains detailed information about the actions performed by the assistant.
        """
        run_steps = self.client.beta.threads.runs.steps.list(
            thread_id=self.thread.id, run_id=self.run.id
        )
        print(f"Run-Steps::: {run_steps}")
        return run_steps.data

    def get_last_response(self):
        """
        Retrieves the last response message from the current thread.

        This method queries the OpenAI API to get the list of messages from the current thread identified by `self.thread.id`.
        It then extracts the last message from this list, assuming the messages are returned in chronological order, with the most recent message first.
        The content of the last message is then extracted and returned.

        Returns:
            str: The text content of the last message in the thread.
        """
        messages = self.client.beta.threads.messages.list(thread_id=self.thread.id)
        last_message = messages.data[0]
        response = last_message.content[0].text.value
        
        return response
        


def main():
    """
    The main function that orchestrates the flow of the application.

    This function initializes the AssistantManager, and handles the logic for creating an assistant, 
    creating a thread, adding a message to the thread, running the assistant, waiting for the completion of the assistant's processing.
    """
    
    manager = AssistantManager()
    
    # Create an assistant with specific instructions and tools
    
    # TODO: Here we have to change the name and instructions as well as the tools.
    manager.create_assistant(
        name="News Summarizer",
        instructions="You are a personal article summarizer Assistant who knows how to take a list of article's titles and descriptions and then write a short summary of all the news articles",
        tools=[
            {
                "type": "function",
                "function": {
                    "name": "get_news",
                    "description": "Get the list of articles/news for the given topic",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "topic": {
                                "type": "string",
                                "description": "The topic for the news, e.g. bitcoin",
                            }
                        },
                        "required": ["topic"],
                    },
                },
            }
        ],
    )
    # Create a thread for communication
    manager.create_thread()
    
    while True:
        # TODO: here are the functions to add from other modules
        # voice_user_input = get_message_from_voice()
        # user_input_text = convert_voice_to_text()
        
        # ! this is only temporary
        user_input_text = input("Enter the instructions: ")
        
        if user_input_text == "q":
            break

        # Add the user's request as a message in the thread
        # * Example of how to use this:
        # *manager.add_message_to_thread(
        # *    role="user", content=f"summarize the news on this topic {user_input_text}?"
        # *)
        
        manager.add_message_to_thread(
            role="user", content=user_input_text
        )
        
        # Run the assistant to process the request
        # * Example of how to use this:
        # * manager.run_assistant(instructions="Summarize the news.")
        
        manager.run_assistant(instructions="Answer the user.")

        # Wait for the assistant to complete processing
        manager.wait_for_completion()
        
        response = manager.get_last_response()
        print(f"RESPONSE::: {response}")


if __name__ == "__main__":
    main()
